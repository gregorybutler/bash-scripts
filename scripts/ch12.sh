#!/bin/bash

ch12_1(){
    cmd1=([1]=": > out.txt" [2]="This command truncates out.txt or creates it if it doesn't exist")
    cmd2=([1]="> out.txt" [2]="This does the samem thing but in a simpler form")
    cmd3=([1]="alias mygrep='grep --color=tty -d skip'" [2]="Setting an alias for a command")
    cmd4=([1]="time ls" [2]="Internal time command")
    cmd5=([1]="/usr/bin/time ls" [2]="External time command")
    cmd6=([1]="help time" [2]="Help machanisms work only for external commands")
    
    for i in $(seq 1 6); do
        cmd=cmd$i[1]
        desc=cmd$i[2]
        run_command "${!cmd}" "${!desc}"
    done
}

ch12_2(){
    cmd1=([1]="ls -l | sort" [2]="Two processes are created, one generated by the executable at /bin/ls and the other by /usr/bin/sort")
    for i in $(seq 1 1); do
        cmd=cmd$i[1]
        desc=cmd$i[2]
        run_command "${!cmd}" "${!desc}"
    done
}

ch12_3(){
    cmd1=([1]="if test 10 -gt 4; then echo 'mai mare'; else echo 'mai mic'; fi" [2]="Sample inline simple script")
    cmd2=([1]="echo 'echo \"Hello World\"' > out.sh
    
bash out.sh" [2]="Simplest bash file creation and execution")

    for i in $(seq 1 2); do
        cmd=cmd$i[1]
        desc=cmd$i[2]
        run_command "${!cmd}" "${!desc}"
    done
}
ch12_4(){
    # cmd#=([1]="" [2]="")
    cmd1=([1]="echo -n 'test'" [2]="-n deactivates implicit display of a newline character at the end of the line")
    cmd2=([1]="echo -e -ne 'test\n\t\ttest2\n'" [2]="-e allows interpretation of special characters")
    cmd3=([1]="printf '%s     %03d\n' 'test' 20" [2]="Allows the display of a string of chars at std output")
    

    for i in $(seq 1 3); do
        cmd=cmd$i[1]
        desc=cmd$i[2]
        run_command "${!cmd}" "${!desc}"
    done
    
}
ch12_5(){
    cmd1=([1]="echo \"Press enter to key to write input to variable\"
read a
echo \$a" [2]="Read is used to read data from standard input and storing them into a variable. If running this command the terminal will await your input")
    cmd2=([1]="echo \"Press enter to key to write input to screen or ctrl+d to return to the previous menu\"
cat" [2]="Cat utilitary")
    cmd3=([1]="echo '#!/bin/bash

echo \"Hello, World!\"

exit 0' > hw.bash
cat < hw.bash" [2]="Redirecting a file to std input. Will display the content of the file")
    cmd4=([1]="cat > out.txt
cat out.txt" [2]="Save to file. Type contents and then press ctrl+D")
    cmd5=([1]="cat < hw.bash > new.bash" [2]="Input from file to new file. Cool?")
    cmd6=([1]="gcc main.c 2> err_warn.txt
cat err_warn.txt" [2]="C errors to text file")
    cmd6=([1]="gcc main.c 2> /dev/null" [2]="C errors to nowhere, no file, no std output")
    cmd7=([1]="strace ls &> out.txt
cat out.txt" [2]="strace output redirect to file")
    cmd8=([1]="ls > out.txt
ps > out.txt
uptime > out.txt
cat out.txt" [2]=">> operator appends")
    cmd9=([1]="echo '#!/bin/bash
cat <<END
multi
line
message
END

echo \"it is over\"' > out.sh

bash out.sh" [2]="<< here document operator. Advantage being that you dont have to write multiple echos")
    cmd10=([1]="read a b c d <<< 'alfa beta gamma delta'

echo \$a \$b \$c \$d" [2]="<<< operator that allows here strings")

    for i in $(seq 1 10); do
        cmd=cmd$i[1]
        desc=cmd$i[2]
        run_command "${!cmd}" "${!desc}"
    done
}

ch12_6(){
    cmd1=([1]="cat out.txt | grep execve" [2]="Command chaining with the | (pipe) operator")
    cmd2=([1]="echo 'Enter current day of the week, ex: Mon, and press enter'
read a
last -30 | grep \$a" [2]="System authentications from the Monday day")
    cmd3=([1]="echo 'Enter current day of the week, ex: Mon, and press enter'
read a
last -30 | grep \$a | cut -d' ' -f1" [2]="Only users from previous command")
    cmd4=([1]="echo 'Enter current day of the week, ex: Mon, and press enter'
read a
last -30 | grep \$a | cut -d' ' -f1 | sort | uniq" [2]="Sort and uniq utilitaries")
    cmd5=([1]="echo 'Enter current day of the week, ex: Mon, and press enter'
read a
last -30 | grep \$a | cut -d' ' -f1 | sort | uniq | wc -l" [2]="Number of authentications")
    for i in $(seq 1 5); do
        cmd=cmd$i[1]
        desc=cmd$i[2]
        run_command "${!cmd}" "${!desc}"
    done
}
ch12_7(){
    cmd1=([1]="a=0
b='alfa'
c='a08ss'
d=230" [2]="Variable definitions ans assignations")
    cmd2=([1]="a =0
b = 'alfa'
d= 230" [2]="Programming fragility in shell. No spaces after or before the equal sign.")
    cmd3=([1]="${cmd1[1]}
echo \$a \$b \$c \$d" [2]="\$ sign references the variable")
    cmd4=([1]="${cmd1[1]}
f=\"\$b\$c\"
echo \$f" [2]="Initialization of variable f with the concatenation of variables b and c")
    cmd5=([1]="a=4
c=3
echo \$((\$a * \$c + 1))" [2]="Arithmetic operations")
    cmd6=([1]="local_users_num=\$(cat /etc/passwd | grep /home | wc -l)
echo \$local_users_num" [2]="Initialisation of local_users_num with the number of users which have base directory /home")
    cmd7=([1]="total_local=\$(\$local_users_num + 1))" [2]="Add the root user to that variable count")
    cmd8=([1]="num_dirs=\$(ls -l | wc -l)
echo \$num_dirs" [2]="\$ sign allows command expansion")
    cmd9=([1]="echo 2+3+4" [2]="Arithmetic operators will be considered simple characters")
    cmd10=([1]="echo \$((2+3+4))" [2]="Arithmetic expansion")
    cmd11=([1]="c=3
b=a
echo \"c = \$c; b = \$b\"" [2]="Double quotes sign is used to keep the character meaning for special characters: blak( ), comma(,), ampersand(&), pipe(|)")
    
    for i in $(seq 1 11); do
        cmd=cmd$i[1]
        desc=cmd$i[2]
        run_command "${!cmd}" "${!desc}"
    done
}
ch12_8(){
    cmd1=([1]="a=3
echo \$a
echo \\\$a" [2]="Notice we cant display the \$ sign")
    cmd2=([1]="echo \\\"" [2]="Make the double quote character a string")
    cmd3=([1]="echo \\" [2]="Display backslash (\\)")
    cmd4=([1]="echo '\" ) ; & $ \'" [2]="The single quote can be used to make special chars a string")
    cmd5=([1]="dpkg -l n*" [2]="Display all packagese wich start with n")
    for i in $(seq 1 5); do
        cmd=cmd$i[1]
        desc=cmd$i[2]
        run_command "${!cmd}" "${!desc}"
    done
}
ch12_9(){
    cmd1=([1]="echo '#!/bin/bash
a=1
if test \$a = 1; then
echo \"Is 1\"
elif test \$a = 2; then
echo \"Is 2\"
else
echo \"Is whatever\"
fi' > out.sh
bash out.sh" [2]="The if conditional")
    cmd2=([1]="test \"alfa\" = alfa
echo \$?
test \"alfa\" = alf
echo \$?" [2]="The test utilitary returns 0 if the condition is met, 1 if not.")
    cmd3=([1]="[ \"alfa\" = alfa ]
echo \$?
[ \"alfa\" = alf ]
echo \$?" [2]="\$? variable is a predefined variable which stores the previous returned value. [] is the shell test operator")
    cmd4=([1]="echo '#!/bin/bash

user=\$(whoami)
if grep \"\$user\" /etc/passwd | grep \"/home\"; then
echo \"User \$user is not homeless.\"
else
echo \"User \$user is homeless.\"
fi' > out.sh
bash out.sh" [2]="If conditional used on evaluation of grep command")
    cmd5=([1]="if ! test 4 -gt 5; then echo \"4 nu e mai mare ca 5\"; else echo \"4 e mai mare ca 5\"; fi" [2]="Negation of a expression")
    cmd6=([1]="if ((1 < 4)); then echo \"adevarat\"; fi" [2]="... expansion operator")
    cmd7=([1]="echo '#!/bin/bash
var=\"Alfa\"
case \$var in
[a-z]*) echo \"litera mica\";;
[A-Z]*) echo \"litera mare\";;
[0-9]*) echo \"cifra\";;
*) echo \"altceva\";;
esac' > out.sh
bash out.sh" [2]="The case instruction")
    for i in $(seq 1 8); do
        cmd=cmd$i[1]
        desc=cmd$i[2]
        run_command "${!cmd}" "${!desc}"
    done
}
ch12_10(){
    cmd1=([1]="echo '#!/bin/bash
sum=0
for i in 1 2 3 4 5 6 7 8 9 10; do
sum=\$((\$sum + \$i))
done
echo \"Suma este: \$sum\"' > out.sh
bash out.sh" [2]="For iterator")
    cmd2=([1]="seq 1 4" [2]="Generating a list using seq")
    cmd3=([1]="echo '#!/bin/bash
sum=0
for i in \$(seq 1 100); do
sum=\$((\$sum + \$i))
done
echo \"Suma este: \$sum\"
' > out.sh
bash out.sh" [2]="Seq and a for")
    cmd4=([1]="echo '#!/bin/bash
i=1
n=10
sum=0
while test \$i -le \$n; do
sum=\$((\$sum + \$i))
((i++))
done
echo \"Suma este: \$sum\"' > out.sh
bash out.sh" [2]="Sum of the first 10 natural numbers using while iterator")
    cmd5=([1]="echo '#!/bin/bash
i=1
sum=0
n=10
until test \$i -gt \$n; do
sum=\$((\$sum + \$i))
i=\$((\$i + 1))
done
echo \"Suma este: \$sum\"' > out.sh
bash out.sh" [2]="Until command resembling while")
    for i in $(seq 1 5); do
        cmd=cmd$i[1]
        desc=cmd$i[2]
        run_command "${!cmd}" "${!desc}"
    done
}

ch12_11(){
    cmd1=([1]="tr a b <<< 'acadaeaf'
tr acd  xyz <<< 'acadaeaf'
tr a-z A-Z <<< 'acadaeaf'
tr '[:lower:]' '[:upper:]' <<< 'acadaeaf'" [2]="The tr utilitary is used to translate at a caracter level the input informations")
    cmd2=([1]="tr -s ' ' <<< 'a b c'" [2]="Eliminating chars which are repeating")
    cmd3=([1]="tr -s a-z A-Z <<< 'aa bb cc'" [2]="Replacing small characters with the same, but capitalized ones")
    cmd4=([1]="wc < out.sh" [2]="Counting characters in a text file")
    cmd5=([1]="wc -l < out.sh" [2]="Displaying the number of lines in a text file")
    cmd6=([1]="grep 'bash' < out.sh" [2]="Finding a certain keyword in a text file")
    cmd7=([1]="echo 'Andreea Popescu
Alin lonescu
Mihai Francu
Calin Antonescu
Silvia Asavei
Doina Ignat' > out.txt
sed 's/Alin/ALIN/' out.txt" [2]="Sed utilitary is used to apply text transformations of a data flow.")
    cmd8=([1]="sed '2q' out.txt" [2]="(q) function stops the reading from file entry. Only two lines are shown (quit)")
    cmd9=([1]="sed '/Calin/q' out.txt" [2]="Display lines until Calin is found")
    cmd10=([1]="sed 's/\([a-zA-Z]*\) \([a-zA-Z]*\) /\2 \1/' out.txt" [2]="Column substitution using regex. We replace the name column with the surname column")
    cmd11=([1]="cut -d ':' -f 1,6 /etc/passwd
echo '=================='
awk -F ':' '{print \$1,\":\",\$6;}' /etc/passwd" [2]="Awk can be used as an advanced form of the cut utilitary. Cut and awk by comparison")
    cmd12=([1]="awk -F ':' '{ printf \"|%-15s|%-25s|\\n\", \$1, \$6;}' /etc/passwd" [2]="An advantage of awk is that compared to cut it gives the possibility to format the output.")
    cmd13=([1]="echo '#!/usr/bin/awk -f
BEGIN {
current_users = 0;
printf \"+--------------+--------------------------+\\n\";
}
{
current_users++;
if (current_users % 5 == 1)
printf \"|%-15s|%-25s|\\n\", \$1, \$6;
}
END {
printf \"+---------------+--------------------------+\\n\";
}' > out.awk
awk -F ':' -f out.awk /etc/passwd" [2]="Special begin/end clausees allow to apply associated instructions only on the bening and end of the process.")
    cmd14=([1]="/sbin/ifconfig eth0 | head -1 | tr -s '' | cut -d ' ' -f 5
/sbin/ifconfig eth0 | head -1 | awk -F '[\\t]+' '{ print \\\$5; }" [2]="Regex expression usage as a separator")
    for i in $(seq 1 13); do
        cmd=cmd$i[1]
        desc=cmd$i[2]
        run_command "${!cmd}" "${!desc}"
    done
}

ch12_12(){
    cmd1=([1]="ls -a
echo 'tmp1.txt
tmp2.txt
tmp3.txt' > out.txt
xargs touch < out.txt
echo '======'
ls -a
xargs rm < out.txt" [2]="Xargs allows the transmission of arguments to another command as standard input. In this example, we display current folder contents, we create a file with file names, we create the files, display the content again as a before/after, then finnaly we remove those files.")
    cmd2=([1]="cut -d ':' -f 1 < /etc/passwd | sort | xargs echo" [2]="The same example but with echo as xargs argument")
    cmd3=([1]="time locate strace" [2]="Locate allows the pinpointing of files which names coresponds to a certain pattern sent as a parameter")
    cmd4=([1]="locate -e strace | xargs file" [2]="Locate is used many times with xargs")
    cmd5=([1]="find -type f -name '*.c' -print" [2]="The main command used to search the local system")
    cmd6=([1]="find /usr/bin -type -l" [2]="Entry type is specified with type and l means a symbolic link")
    cmd7=([1]="find /usr/bin -type d -wholename cpp" [2]="Display folders which contain cpp in their name")
    cmd8=([1]="find /usr/bin -perm 4755" [2]="Find files with the a specific permission")
    cmd9=([1]="find /home -type f -mtime +100" [2]="Find files older than 100 days")
    cmd10=([1]="find /home/ -size +200M" [2]="Find files larger than 200mb")
    cmd11=([1]="find . -type f -name ' *~' -delete" [2]="Deletion of temporary files from the local user")
    cmd12=([1]="find -type f -name '*.c' -exec grep -l 'int main*' '{}' ';'" [2]="Display c files which have the main function in them")
    cmd13=([1]="find /tmp -type f -user $(whoami) -delete" [2]="Deletion of files from tmp directory")
    for i in $(seq 1 13); do
        cmd=cmd$i[1]
        desc=cmd$i[2]
        run_command "${!cmd}" "${!desc}"
    done
}

ch12_13(){
    cmd1=([1]="ls *.c" [2]="Regular expression to list a C file in the current directory")
    for i in $(seq 1 1); do
        cmd=cmd$i[1]
        desc=cmd$i[2]
        run_command "${!cmd}" "${!desc}"
    done
}

ch12_14(){
    cmd1=([1]="echo '#!/bin/bash
echo \"Scriptul are \$# argumente.\"
echo \"Numele scriptului este \$0.\"
echo \"Argumentele scriptului sunt \$@.\"
i=1
while test \$i -le \$#; do
echo \"Argumentul \$i este \${!i}.\"
((i++))
done' > out.sh
bash out.sh alfa beta gamma delta" [2]="Bash file which accepts N arguments")
    cmd2=([1]="echo '#!/bin/bash
i=1
for arg in \$@; do
echo \"Argumentul \$i este \$arg.\"
((i++))
done' > out.sh
bash out.sh alfa beta gamma delta" [2]="Another way of parsing arguments is with a for")
    cmd3=([1]="echo '#!/bin/bash
i=1
while ! test -z \$1; do
echo \"Argumentul \$i este \$1.\"
((i++))
shift
done' > out.sh
bash out.sh alfa beta gamma delta" [2]="The shift command is responsible with the moving to the left of arguments. Hence, after running the shift command, information about the left most argument is lost.")
    cmd4=([1]="echo '#!/bin/bash
if test \$# -ne 2; then
echo 'Two arguments are required'
exit 1
fi
if ! test -d \$1; then
echo 'First argument is not a directory'
exit 1
fi
find \"\$1\" -type f -name \"\$2\"' > out.sh
bash out.sh . \"*.c\"" [2]="Nice example of a bash script using parameters that finds C files")
    for i in $(seq 1 4); do
        cmd=cmd$i[1]
        desc=cmd$i[2]
        run_command "${!cmd}" "${!desc}"
    done
}
ch12_15(){
    cmd1=([1]="echo '#!/bin/bash
if test \$# -ne 1; then
echo \"One argument is required: a or b\"
fi
function a()
{
    echo \"a\"
}
function b()
{
    echo \"b\"
}
case \$1 in
    \"a\") a;;
    \"b\") b;;
    *) echo \"Required arguments are a or b\"; exit 1;;
esac' > out.sh
bash out.sh a
bash out.sh b" [2]="Here we demonstrate the calling of a script function using the parameter of the script")
    cmd2=([1]="echo '#!/bin/bash
sum_func()
{
    sum=0
    while ! test -z \$1; do
    sum=\$((\$sum + \$1))
    shift
    done
}
sum_func 1 2 3 4 5
echo \"Sum: \$sum\"
sum_func 2 3 5 7 11 13 17 19
echo \"Sum: \$sum\"' > out.sh
bash out.sh" [2]="Script with a function that accepts arguments")
    for i in $(seq 1 2); do
        cmd=cmd$i[1]
        desc=cmd$i[2]
        run_command "${!cmd}" "${!desc}"
    done
}
ch12_16(){
    cmd1=([1]="export myVariable=\"myValue\"
echo \$myVariable" [2]="Setting an environment variable")
    cmd2=([1]="env" [2]="Showing enviromnent variables")
    for i in $(seq 1 2); do
        cmd=cmd$i[1]
        desc=cmd$i[2]
        run_command "${!cmd}" "${!desc}"
    done
}
menu_ch12(){
    clear_screen
    echo "Chapter Twelve "
    echo -e "(a) Internal & External Commands"
    echo -e "(b) Command chaining"
    echo -e "(c) Shell scripts"
    echo -e "(d) Simple shell commands"
    echo -e "(e) Outputing"
    echo -e "(f) Command chaining"
    echo -e "(g) Variables"
    echo -e "(h) Special characters"
    echo -e "(i) Decision instructions"
    echo -e "(j) Iterators"
    echo -e "(k) Text filters"
    echo -e "(l) Commands for working with files"
    echo -e "(m) Regular expressions"
    echo -e "(n) Parameters of a shell script"
    echo -e "(o) Functions"
    echo -e "(p) Environment variables"
    echo -e "(x) Return to main menu"
    echo
}

read_opt_ch12(){
    echo -n "Please enter your choice: "
    read -r choice
    case $choice in 
        "a"|"A"|"1")
            clear_screen
            ch12_1
            pause
            ;;
        "b"|"B"|"2")
            clear_screen
            ch12_2
            pause
            ;;
        "c"|"C"|"3")
            clear_screen
            ch12_3
            pause
            ;;
        "d"|"D"|"4")
            clear_screen
            ch12_4
            pause
            ;;
        "e"|"E"|"5")
            clear_screen
            ch12_5
            pause
            ;;
        "f"|"F"|"6")
            clear_screen
            ch12_6
            pause
            ;;
        "g"|"G"|"7")
            clear_screen
            ch12_7
            pause
            ;;
        "h"|"H"|"8")
            clear_screen
            ch12_8
            pause
            ;;
        "i"|"I"|"9")
            clear_screen
            ch12_9
            pause
            ;;
        "j"|"J"|"10")
            clear_screen
            ch12_10
            pause
            ;;
        "k"|"K"|"11")
            clear_screen
            ch12_11
            pause
            ;;
        "l"|"L"|"12")
            clear_screen
            ch12_12
            pause
            ;;
        "m"|"M"|"13")
            clear_screen
            ch12_13
            pause
            ;;
        "n"|"N"|"14")
            clear_screen
            ch12_14
            pause
            ;;
        "o"|"O"|"15")
            clear_screen
            ch12_15
            pause
            ;;
        "p"|"P"|"16")
            clear_screen
            ch12_16
            pause
            ;;
        "x"|"X")
            clear_screen
            main_menu
            ;;
        *)
            echo -e "${RED}[${choice}]${STD} is not a valid option"
            pause
            ;;
    esac
}

ch12(){
    while true
	do
		menu_ch12
		read_opt_ch12
	done
}